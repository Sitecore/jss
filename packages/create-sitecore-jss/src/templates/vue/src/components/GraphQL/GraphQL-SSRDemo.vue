<!--
-->
<template>
  <div data-e2e-id="graphql-ssr">
    <h2>GraphQL Server Side Rendering Demo</h2>

    <p>
      Server Side GraphQL executes GraphQL queries directly against the Sitecore GraphQL endpoint,
      prior to rendering the app to a string. This sample app uses the <code>vue-apollo</code> library to
      manage GraphQL queries.
    </p>
    <p>
      <strong>NOTE:</strong> when using the <code>useQuery</code> prefetch option,
      GraphQL queries are executed <em>prior</em> to app rendering.
    </p>
    <p>
      Expected behavior for this component:
      <ul>
        <li>
          <strong>Connected Mode:</strong> the GraphQL query will execute in the browser after component load.
          The <code>prefetch</code> option will not execute.
        </li>
        <li>
          <strong>Integrated Mode:</strong> the <code>prefetch</code> option of the GraphQL query will execute on the server
          and output will be rendered in the markup generated by the app on the server. After the initial load / render from
          the server, you can manage the query like a client-side query.
        </li>
        <li><strong>Disconnected Mode:</strong> GraphQL requires connected mode, headless
        connected mode, or integrated mode to work.</li>
      </ul>
    </p>

    <p v-if="loading" class="alert alert-info">GraphQL query is executing...</p>
    <p v-if="error" class="alert alert-danger">GraphQL query error: {{ error.toString() }}</p>
    <div v-if="!loading && result && result.contextItem">
      <h4>Route Item (via SSR Connected GraphQL)</h4>
      id: {{ result.contextItem.id }}
      <br />
      page title: {{ result.contextItem.pageTitle.value }}
      <br />
      children:
      <ul>
        <li v-for="(child) in result.contextItem.children.results" :key="child.id">
          <router-link :to="child.url.path">{{child.pageTitle.value}}</router-link>&nbsp; (editable title too! <sc-text :field="child.pageTitle.jsonValue" />)
        </li>
      </ul>
    </div>
  </div>
</template>

<script>
import { getCurrentInstance, defineComponent, watch } from 'vue';
import { ConnectedDemoQuery } from './GraphQL-ConnectedDemo.query.graphql';
import { useQuery } from "@vue/apollo-composable";
import config from '../../../package.json';

import { Text } from '@sitecore-jss/sitecore-jss-vue';

export default defineComponent({
  name: 'GraphQL-SSRDemo',
  props: {
    fields: {
      type: Object,
    },
    rendering: {
      type: Object,
    },
  },
  components: {
    ScText: Text,
  },
  setup() {
    const instance = getCurrentInstance();

    const variables = () => {
      const properties = instance.appContext.config.globalProperties.$jss;
      const defaultValue = '{00000000-0000-0000-0000-000000000000}';
      const variables = {
        contextItem: properties ? properties.sitecoreContext().itemId : defaultValue,
        datasource: defaultValue,
        language: properties ? properties.sitecoreContext().language : config.language
      };

      if (!variables.contextItem) variables.contextItem = defaultValue;

      return variables;
    }

    const { result, loading, error } = useQuery(ConnectedDemoQuery, variables());

    return {
      result,
      loading,
      error,
    }
  },
  // Workaround for issue https://github.com/vuejs/vue-apollo/issues/1100
  // Prefetch is not working using Composition API
  // Currently @vue/apollo doesn't support Option (Classic) API
  async serverPrefetch() {
    return new Promise((resolve, reject) => {
      watch(
        () => this.loading,
        () => resolve({}),
      );
      watch(
        () => this.error,
        () => reject(),
      );
    });
  },
});
</script>
