<!--
  JSS Sitecore Configuration Patch File

  This configuration file registers the JSS site with Sitecore, and configures the Layout Service
  to work with it. Config patches need to be deployed to the Sitecore server.

  Normally `jss deploy config` can do this for local development. To manually deploy, or to deploy via CI,
  this file can be placed in the `App_Config/Include` folder, or a subfolder of it, within the Sitecore site.
-->
<configuration xmlns:patch="http://www.sitecore.net/xmlconfig/" xmlns:set="http://www.sitecore.net/xmlconfig/set/" xmlns:role="http://www.sitecore.net/xmlconfig/role/">
  <sitecore>
    <settings>
      <!--
        PROXY CONFIGURATION
        When running JSS with the headless proxy (node-headless-ssr-proxy),
        the original IP address of clients is obscured by the proxy.
        This setting tells Sitecore to read the forwarded header the proxy sends,
        thus making analytics track the correct original client IP address.
      -->
      <setting name="Analytics.ForwardedRequestHttpHeader" set:value="X-Forwarded-For" />

      <!--
        JSS EDITING SECRET
        To secure the Experience Editor endpoint exposed by your Next.js app (see `serverSideRenderingEngineEndpointUrl` below),
        a secret token is used. This is taken from an env variable by default, but could be patched and set directly by uncommenting.
        This (server-side) value must match your client-side value, which is configured by the JSS_EDITING_SECRET env variable (see the Next.js .env file).
        We recommend an alphanumeric value of at least 16 characters.

        <setting name="JavaScriptServices.ViewEngine.Http.JssEditingSecret" value="" />
     -->
    </settings>
    <sites>
      <!--
        JSS Site Registration
        This configures the site with Sitecore - i.e. host headers, item paths.
        If your JSS app lives within an existing Sitecore site, this may not be necessary.

        IMPORTANT: JSS sites ship in 'live mode', which makes development and testing easy,
        but disables workflow and publishing. Before going to production, change the `database`
        below to `web` instead of `master`.
      -->
      <site patch:before="site[@name='website']"
            inherits="website"
            name="JssNextWeb"
            hostName="JssNextWeb"
            rootPath="/sitecore/content/JssNextWeb"
            startItem="/home"
            database="master" />
    </sites>
    <javaScriptServices>
      <apps>
        <!--
          JSS App Registration
          The JSS app needs to be registered in order to support layout service and import services.

          There are many available attributes, and they inherit the defaults if not explicitly specified here.
          Defaults are defined in `/App_Config/Sitecore/JavaScriptServices/Sitecore.JavaScriptServices.Apps.config`

          NOTE: graphQLEndpoint enables _Integrated GraphQL_. If not using integrated GraphQL, it can be removed.
        -->
        <app name="JssNextWeb"
            sitecorePath="/sitecore/content/JssNextWeb"
            useLanguageSpecificLayout="true"
            graphQLEndpoint="/api/jssnextweb"
            inherits="defaults"
            serverSideRenderingEngine="http"
            serverSideRenderingEngineEndpointUrl="http://localhost:3000/api/editing/render"
            serverSideRenderingEngineApplicationUrl="http://localhost:3000"
        />
      </apps>
      <!--
        IMAGE RESIZING WHITELIST
        Using Sitecore server-side media resizing (i.e. the `imageParams` or `srcSet` props on the `<Image/>` helper component)
        could expose your Sitecore server to a denial-of-service attack by rescaling an image with many arbitrary dimensions.
        In JSS resizing param sets that are unknown are rejected by a whitelist.

        Sets of image sizing parameters that are used in app components must be whitelisted here.
        If a param set is not whitelisted, the image will be returned _without resizing_.

        To determine the image parameters being used, look at the query string on the `src` of the rendered image, i.e. '/img.jpg?mw=100&h=72' -> mw=100,h=72
        Note: the parameter sets defined here are comma-delimited (,) instead of &-delimited like the query string. Multiple sets are endline-delimited.
       -->
      <allowedMediaParams>
        <!-- XML element name is arbitary, useful for organizing and patching -->
        <styleguide-image-sample>
          mw=100,mh=50
        </styleguide-image-sample>
        <styleguide-image-sample-adaptive>
          mw=300
          mw=100
        </styleguide-image-sample-adaptive>
      </allowedMediaParams>
    </javaScriptServices>
    <api>
      <!--
        Define the app's Sitecore GraphQL API endpoint
        Note: this can be removed if you are not using GraphQL.
        Note: the endpoint must be defined both for integrated and connected type GraphQL queries.
      -->
      <GraphQL>
        <endpoints>
          <JssNextWebGraphQLEndpoint url="/api/jssnextweb" type="Sitecore.Services.GraphQL.Hosting.GraphQLEndpoint, Sitecore.Services.GraphQL.NetFxHost" resolve="true">
            <url>$(url)</url>

            <enabled role:require="ContentDelivery">false</enabled>

            <enableSubscriptions>false</enableSubscriptions>

            <!-- lock down the endpoint when deployed to content delivery -->
            <graphiql role:require="ContentDelivery">false</graphiql>
            <enableSchemaExport role:require="ContentDelivery">false</enableSchemaExport>
            <enableStats role:require="ContentDelivery">false</enableStats>
            <enableCacheStats role:require="ContentDelivery">false</enableCacheStats>
            <disableIntrospection role:require="ContentDelivery">true</disableIntrospection>

            <schema hint="list:AddSchemaProvider">
                <!-- 
                    Edge schema provider. Provides the same response as Edge Delivery GraphQL endpoint
                    Usage: on your endpoint, change your content schema provider to '<content ref="/sitecore/GraphQL/defaults/content/edgeContent" param1="master" />'
                    (where param1 is the database you want to hook to)
                -->
                <edgeContent type="Sitecore.Services.GraphQL.EdgeSchema.EdgeSchemaProvider, Sitecore.Services.GraphQL.EdgeSchema">
                    <!-- 
                        The template predicate defines which templates will have GraphQL types generated for them. This is NOT a security measure - all fields
                        that the API key user/authenticated user can access can be queried by name - but can be used to limit the scope of your GraphQL schema.
                    -->
                    <templates type="Sitecore.Services.GraphQL.Content.TemplateGeneration.Filters.StandardTemplatePredicate, Sitecore.Services.GraphQL.Content">
                        <database>context</database>
                        <paths hint="list:AddIncludedPath">
                            <templates>/sitecore/templates/Project/JssNext</templates>
                        </paths>
                        <fieldFilter type="Sitecore.Services.GraphQL.Content.TemplateGeneration.Filters.StandardFieldFilter, Sitecore.Services.GraphQL.Content">
                            <exclusions hint="raw:AddFilter">
                                <!--
                                    Remove system fields from the API (e.g. __Layout) to keep the schema lean
                                -->
                                <exclude name="__*" />
                            </exclusions>
                        </fieldFilter>
                    </templates>

                    <!-- 
                        Define the GraphQL root object for the schema (queries, mutations, and subscriptions)
                        You may use `resolve=true` to activate dependency injection on root fields.
                        All root fields must inherit from FieldType (EventStreamFieldType for subscriptions)
                        Fields may optionally implement IContentSchemaRootFieldType to get a Database instance (automatic property is expected)
                    -->
                    <queries hint="raw:AddQuery">
                        <query name="item" type="Sitecore.Services.GraphQL.EdgeSchema.Queries.ItemQuery, Sitecore.Services.GraphQL.EdgeSchema" />
                        <query name="layout" type="Sitecore.Services.GraphQL.EdgeSchema.Queries.LayoutQuery, Sitecore.Services.GraphQL.EdgeSchema" />
                        <query name="search" type="Sitecore.Services.GraphQL.EdgeSchema.Queries.SearchQuery, Sitecore.Services.GraphQL.EdgeSchema" />
                    </queries>
                    <fieldTypeMapping ref="/sitecore/api/GraphQL/defaults/content/fieldTypeMappings/standardTypeMapping" />
                </edgeContent>
            </schema>

            <!-- Determines the security of the service. Defaults are defined in Sitecore.Services.GraphQL.config -->
            <security ref="/sitecore/api/GraphQL/defaults/security/publicService" />

            <!-- Determines how performance is logged for the service. Defaults are defined in Sitecore.Services.GraphQL.config -->
            <performance ref="/sitecore/api/GraphQL/defaults/performance/standard" />

            <!--
                Cache improves the query performance by caching parsed queries.
                It is also possible to implement query whitelisting by implementing an authoritative query cache;
                WhitelistingGraphQLQueryCache is an example of this, capturing queries to files in open mode and allowing only captured queries in whitelist mode.
            -->
            <cache type="Sitecore.Services.GraphQL.Hosting.QueryTransformation.Caching.GraphQLQueryCache, Sitecore.Services.GraphQL.NetFxHost">
                <param desc="name">$(url)</param>
                <param desc="maxSize">10MB</param>
            </cache>
          </JssNextWebGraphQLEndpoint>
        </endpoints>
      </GraphQL>
    </api>
  </sitecore>
</configuration>
